var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { prebuild } from '@mintlify/prebuild';
import open from 'better-opn';
import Chalk from 'chalk';
import express from 'express';
import fse, { pathExists } from 'fs-extra';
import { createServer } from 'http';
import isOnline from 'is-online';
import { pathToFileURL } from 'node:url';
import { Server as SocketServer } from 'socket.io';
import { CLIENT_PATH, DOT_MINTLIFY, CMD_EXEC_PATH, VERSION_PATH, NEXT_CONFIG_PATH, NEXT_PUBLIC_PATH, NEXT_PROPS_PATH, NEXT_SIDE_EFFECT_PATH, NEXT_ROUTER_SERVER_PATH, } from '../constants.js';
import { buildLogger, maybeFixMissingWindowsEnvVar } from '../util.js';
import { getTargetMintVersion, downloadTargetMint } from './client.js';
import listener from './listener/index.js';
const dev = (argv) => __awaiter(void 0, void 0, void 0, function* () {
    // Note: We wait for specific text in the logger to be sure the server is ready when we e2e test the cli.
    // If the cli output does not exactly match:
    // "- Preparing local Mintlify instance...\nâœ” Local Mintlify instance is ready. Launching your site...\nYour local preview is available at http://localhost:3000\nPress Ctrl+C any time to stop the local preview."
    // the test will fail/require an update.
    const logger = buildLogger('Preparing local Mintlify instance...');
    const hasInternet = yield isOnline();
    const localSchema = argv['local-schema'];
    const clientVersion = argv['client-version'];
    yield fse.ensureDir(DOT_MINTLIFY);
    const versionString = (yield pathExists(VERSION_PATH))
        ? fse.readFileSync(VERSION_PATH, 'utf8')
        : null;
    if (!versionString && !hasInternet) {
        logger.fail('Running mintlify dev afer updating requires an internet connection.');
        process.exit(1);
    }
    const targetMintVersion = yield getTargetMintVersion(logger);
    if (!targetMintVersion) {
        logger.text =
            'Failed to get latest Mintlify client version. Your current version is: ' +
                versionString +
                ', which may not be the latest Mintlify client version.';
    }
    const shouldDownload = versionString !== targetMintVersion || clientVersion !== undefined;
    if (shouldDownload && hasInternet && targetMintVersion) {
        yield downloadTargetMint(logger, targetMintVersion, versionString, clientVersion);
    }
    // clear preexisting prebuild files
    fse.emptyDirSync(NEXT_PUBLIC_PATH);
    fse.emptyDirSync(NEXT_PROPS_PATH);
    process.chdir(CLIENT_PATH);
    try {
        yield prebuild(CMD_EXEC_PATH, { localSchema });
    }
    catch (err) {
        const errorText = err instanceof Error && err.message ? err.message : 'Prebuild step failed';
        logger.fail(errorText);
        process.exit(1);
    }
    logger.succeed('Local Mintlify instance is ready. Launching your site...');
    yield run(argv);
});
/**
 * When creating a standalone build, next.js outputs a server.js file that can be used as
 * an entry point into the server. However, because we want to customize some parts of the
 * http server (adding a socket.io server, serving the whole public directory), we
 * create the server ourselves, and just reproduce the setup that next.js would do.
 *
 * Because we need to directly import from node_modules files, this solution seems very hacky,
 * but it is arguably no more hacky than using the server.js that ships with the standalone
 * build.
 *
 * This function attempts to replicate the behavior of two next.js files:
 * - environment setup from server.js
 * - initialization of the request handler from start-server.ts
 *
 * Links:
 * - [standalone build](https://nextjs.org/docs/pages/api-reference/next-config-js/output#automatically-copying-traced-files)
 * - [server.js](https://github.com/vercel/next.js/blob/492156b4c5e2559b2a280f7d483cd85a8e8742a9/packages/next/src/build/utils.ts#L2108-L2113) (created programmatically)
 * - [start-server.ts](https://github.com/vercel/next.js/blob/492156b4c5e2559b2a280f7d483cd85a8e8742a9/packages/next/src/server/lib/start-server.ts#L296-L308)
 *
 * @returns the request handler provided by next.js
 */
const setupNext = () => __awaiter(void 0, void 0, void 0, function* () {
    const hostname = process.env.HOSTNAME || 'localhost';
    const { config } = yield JSON.parse(fse.readFileSync(NEXT_CONFIG_PATH, 'utf8'));
    process.env.__NEXT_PRIVATE_STANDALONE_CONFIG = JSON.stringify(config);
    // The server.js provided by next.js's standalone build does a similar import of this file.
    // Not sure what side effects are being created, but want to change as little as possible.
    // Also, Windows requires us to use `pathToFileURL` (see #899)
    yield import(pathToFileURL(NEXT_SIDE_EFFECT_PATH).href);
    const { initialize } = yield import(pathToFileURL(NEXT_ROUTER_SERVER_PATH).href);
    const [requestHandler] = yield initialize({
        dir: CLIENT_PATH,
        dev: false,
        hostname,
        minimalMode: true,
    });
    return requestHandler;
});
const run = (argv) => __awaiter(void 0, void 0, void 0, function* () {
    const port = argv.port || '3000';
    const currentPort = parseInt(port, 10) || 3000;
    const app = express();
    const server = createServer(app);
    const io = new SocketServer(server);
    const requestHandler = yield setupNext();
    // next-server is bugged, public files added after starting aren't served
    app.use('/', express.static(NEXT_PUBLIC_PATH));
    app.all('*', (req, res) => requestHandler(req, res));
    const onChange = () => {
        io.emit('reload');
    };
    server.listen(currentPort, () => {
        console.log(`${Chalk.green(`Your local preview is available at http://localhost:${port}`)}`);
        // Note: We wait for this exact text to be sure the server is ready in the cli e2e test,
        // if it changes, the test will fail/require an update.
        console.log(`${Chalk.green('Press Ctrl+C any time to stop the local preview.')}`);
        /**
         * We're running into a known bug with the `open` package, where Windows machines error out because process.env.SYSTEMROOT is not set:
         * https://github.com/sindresorhus/open/issues/292
         *
         * Let's use the same workaround that this project did:
         * https://github.com/sanity-io/sanity/pull/4221/files#diff-aeb574e1becf61f21fdf87fbea709669c93d604d660dad4b0f9e24527a2fb54bR256-R262
         */
        maybeFixMissingWindowsEnvVar();
        if (argv.open) {
            void open(`http://localhost:${port}`);
        }
        // exit with successful status
        const onExit = () => {
            process.exit(0);
        };
        process.on('SIGINT', onExit);
        process.on('SIGTERM', onExit);
    });
    listener(onChange);
});
export default dev;
